---
title: "Trabajo de datos en área"
author: "Jennifer Salazar"
date: "28/6/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Modelación de datos en área

## 9.1 Introducción

## 9.2 Vecinos espacial y pesos espaciales

```{r}
vignette("nb", package = "spdep")
```


# 9.2.1 Vecinos espaciales

```{r}
library(spdep)
library(rgdal)
NY8 <- readOGR(".", "NY8_utm18")
NY_nb <- read.gal("NY_nb.gal", region.id = row.names(NY8))
summary(NY_nb)
```


```{r}
plot(NY8, border = "grey60")
plot(NY_nb, coordinates(NY8), pch = 19, cex = 0.6, add = TRUE)
```



```{r}
Syracuse <- NY8[NY8$AREANAME == "Syracuse city", ]
Sy0_nb <- subset(NY_nb, NY8$AREANAME == "Syracuse city")
summary(Sy0_nb)
```



```{r}
coords <- coordinates(Syracuse)
IDs <- row.names(Syracuse)
Sy8_nb <- knn2nb(knearneigh(coords, k = 1), row.names = IDs)
Sy9_nb <- knn2nb(knearneigh(coords, k = 2), row.names = IDs)
Sy10_nb <- knn2nb(knearneigh(coords, k = 4), row.names = IDs)
dsts <- unlist(nbdists(Sy8_nb, coords))
Sy11_nb <- dnearneigh(coords, d1 = 0, d2 = 0.75 * max(dsts),row.names = IDs)
```


<br>

## 9.2.2 Objetos de pesos espaciales

```{r}
Sy0_lw_W <- nb2listw(Sy0_nb)
Sy0_lw_W
```



```{r}
names(Sy0_lw_W)
```


```{r}
names(attributes(Sy0_lw_W))
```



```{r}
1/rev(range(card(Sy0_lw_W$neighbours)))
summary(unlist(Sy0_lw_W$weights))
```


```{r}
Sy0_lw_B <- nb2listw(Sy0_nb, style = "B")
summary(unlist(Sy0_lw_B$weights))
```

```{r}
summary(sapply(Sy0_lw_B$weights, sum))
```


```{r}
dsts <- nbdists(Sy0_nb, coordinates(Syracuse))
idw <- lapply(dsts, function(x) 1/(x/1000))
Sy0_lw_idwB <- nb2listw(Sy0_nb, glist = idw, style = "B")
summary(unlist(Sy0_lw_idwB$weights))
```


```{r}
summary(sapply(Sy0_lw_idwB$weights, sum))
```




```{r}
Sy0_lw_D1 <- nb2listw(Sy11_nb, style = "B")
```


```{r}
Sy0_lw_D1 <- nb2listw(Sy11_nb, style = "B", zero.policy = TRUE)
print(Sy0_lw_D1, zero.policy = TRUE)
```

<br>

### 9.2.3 Manejo de objetos de pesos espaciales


```{r}
Sy14_nb <- read.gal("Sy_GeoDa1.GAL")
isTRUE(all.equal(Sy0_nb, Sy14_nb, check.attributes = FALSE))
```


```{r}
Sy16_nb <- read.gwt2nb("Sy_GeoDa4.GWT")
isTRUE(all.equal(Sy10_nb, Sy16_nb, check.attributes = FALSE))
```

<br>

### 9.2.4 Uso de pesos para simular la autocorrelación espacial


```{r}
set.seed(987654)
n <- length(Sy0_nb)
uncorr_x <- rnorm(n)
rho <- 0.5
autocorr_x <- invIrW(Sy0_lw_W, rho) %*% uncorr_x
```


<br>

## 9.3 Prueba de autocorrelación espacial


```{r}
moran_u <- moran.test(uncorr_x, listw = Sy0_lw_W)
moran_a <- moran.test(autocorr_x, listw = Sy0_lw_W)
moran_a1 <- moran.test(autocorr_x, listw = nb2listw(Sy9_nb,
 style = "W"))
```


```{r}
et <- coords[, 1] - min(coords[, 1])
trend_x <- uncorr_x + 0.00025 * et
moran_t <- moran.test(trend_x, listw = Sy0_lw_W)
moran_t1 <- lm.morantest(lm(trend_x ~ et), listw = Sy0_lw_W)
```


<br>

### 9.3.1 Pruebas globales


```{r}
moran.test(NY8$Cases, listw = nb2listw(NY_nb))
```

```{r}
lw_B <- nb2listw(NY_nb, style = "B")
moran.test(NY8$Cases, listw = lw_B)
```

```{r}
moran.test(NY8$Cases, listw = lw_B, randomisation = FALSE)
```

```{r}
lm.morantest(lm(Cases ~ 1, NY8), listw = lw_B)
```

```{r}
lm.morantest.sad(lm(Cases ~ 1, NY8), listw = lw_B)
```


```{r}
lm.morantest.exact(lm(Cases ~ 1, NY8), listw = lw_B)
```



```{r}
set.seed(1234)
bperm <- moran.mc(NY8$Cases, listw = lw_B, nsim = 999)
bperm
```


```{r}
r <- sum(NY8$Cases)/sum(NY8$POP8)
rni <- r * NY8$POP8
CR <- function(var, mle) rpois(length(var), lambda = mle)
MoranI.pboot <- function(var, i, listw, n, S0, ...) {
 return(moran(x = var, listw = listw, n = n, S0 = S0)$I)
}

set.seed(1234)
library(boot)
boot2 <- boot(NY8$Cases, statistic = MoranI.pboot,
 R = 999, sim = "parametric", ran.gen = CR,
 listw = lw_B, n = length(NY8$Cases), S0 = Szero(lw_B),
 mle = rni)
pnorm((boot2$t0 - mean(boot2$t))/sd(boot2$t[, 1]), lower.tail = FALSE)
```

```{r}
rni <- fitted(glm(Cases ~ 1 + offset(log(POP8)), data = NY8,
 family = "poisson"))
```



```{r}
set.seed(1234)
EBImoran.mc(n = NY8$Cases, x = NY8$POP8, listw = nb2listw(NY_nb,
 style = "B"), nsim = 999)
```


```{r}
cor8 <- sp.correlogram(neighbours = NY_nb, var = NY8$Cases,
 order = 8, method = "I", style = "C")
```


```{r}
library(pgirmess)
corD <- correlog(coordinates(NY8), NY8$Cases, method = "Moran")
```



### 9.3.2 Pruebas locales


```{r}
moran.plot(NY8$Cases, listw = nb2listw(NY_nb, style = "C"))
```




```{r}
lm1 <- localmoran(NY8$Cases, listw = nb2listw(NY_nb,
 style = "C"))
lm2 <- as.data.frame(localmoran.sad(lm(Cases ~ 1, NY8),
 nb = NY_nb, style = "C"))
lm3 <- as.data.frame(localmoran.exact(lm(Cases ~ 1, NY8),
 nb = NY_nb, style = "C"))
```



```{r}
r <- sum(NY8$Cases)/sum(NY8$POP8)
rni <- r * NY8$POP8
lw <- nb2listw(NY_nb, style = "C")
sdCR <- (NY8$Cases - rni)/sqrt(rni)
wsdCR <- lag(lw, sdCR)
I_CR <- sdCR * wsdCR
```



```{r}
set.seed(1234)
nsim <- 999
N <- length(rni)
sims <- matrix(0, ncol = nsim, nrow = N)
for (i in 1:nsim) {
 y <- rpois(N, lambda = rni)
 sdCRi <- (y - rni)/sqrt(rni)
 wsdCRi <- lag(lw, sdCRi)
 sims[, i] <- sdCRi * wsdCRi
 }
xrank <- apply(cbind(I_CR, sims), 1, function(x) rank(x)[1])
diff <- nsim - xrank
diff <- ifelse(diff > 0, diff, 0)
pval <- punif((diff + 1)/(nsim + 1))
```


<br>


## Ajuste de modelos de datos en área 

Generalmente a la hora de realizar análisis estadístico se busca que los datos sean independientes entre sí, eso seria lo ideal, pero la realidad es muy distinta y en los datos de área se encuentra autocorrelación espacial que es afirmada por los tests que ya vimos anteriormente, en algunos casos hay información de covariables que nos ayuda a modelar esta dependencia espacial, pero en otros casos no, por lo que el objetivo es mirar como se puede modelar la estructura de autocorrelación espacial.
 
### 9.4.1 Enfoques estadísticos espaciales


Cuando se trabaja con datos se esperan que las observaciones sean independientes, con los datos espaciales esto generalmente no pasa, pues hay una dependencia espacial en el fondo y esto sucede con los datos en área, en esta primera sección vamos a trabajar modelos autoregresivos para modelar la dependencia espacial. Desde un punto estadístico se puede dar cuenta de las observaciones correlacionadas considerando una estructura del siguiente tipo en el modelo. Si el vector de respuestas es normal multivariado, podemos expresar el modelo de la siguiente manera: 

$$Y = \mu + e$$

Donde $\mu$ es el vector de medias que se puede modelar de diferentes maneras y $e$ es el vector de errores aleatorios que se asume con una distribución normal con media cero y viarianza $V$. Muchas veces se asume que la media depende de un termino lineal de covariables, entonces cambiaremos a $\mu$ por $X^T\beta$, por otro lado, la correlación entre áreas se puede considerar dandodele una forma especifica a la matriz de varianza $V$. Muchas estructuras de correlación espacial podrían ser viables para dar cuenta de la dependencia espacial, sin embargo, nos vamos a enfocar en los dos enfoques que usan comúnmente en la practica que son los modelos SAR(autoregresivo simultáneo) y CAR(autoregresivo condicional).

Anteriormente, se tomaron la media de los recuentos de casos de leucemia por área, hay varias alternativas para manejar la heterogeneidad proveniente de las variaciones en las poblaciones, una de las alternativas propuestas por Waller y Gotway(2004, p. 348) es realizar una transformación logarítmica de la tasa: 

$$Z_i = log \frac{1000(Y_i + 1)}{n_i}$$

La transformación de las incidencias de proporciones aún no son normales, cuenta con tres valores atípicos que pueden ser interesantes, ya que los patrones que muestran pueden estar relacionados con covariables sustanciales, como covariables se utilizaran: la inversa de la distancia al TCE más cercano (PEXPOSURE), la proporción de personas de 65 años o más (PCTAGE65) y la proporción de personas con vivienda propia (PCTWNHOME). Para ejemplificar, comencemos con un modelo lineal de la relación entre las proporciones de incidencia transformadas y las covariables.  

```{r}
nylm <- lm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = NY8)
summary(nylm)
NY8$lmresid <- residuals(nylm)
```

Del resumen anterior se puede decir que la proporción de adultos mayores a los 65 años y la proporción de personas con vivienda propia parece contribuir a la explicación de la variabilidad de la variable respuesta, pero la exposición al TCE no lo hace, se observa que sigue habiendo mucha información en los residuales que podríamos tratar de utilizar.

Ya que la prueba de Moran está destinada a detectar la autocorrelación espacial, podemos intentar ajustar un modelo que tenga esto en cuenta. Sin embargo, no debemos olvidar que las especificaciones erróneas detectadas por Moran pueden tener una variedad de causas. 

```{r}
library(spdep)
NYlistw <- nb2listw(NY_nb, style = "B")
lm.morantest(nylm, NYlistw)
```

```{r}
NYlistwW <- nb2listw(NY_nb, style = "W")
aple(residuals(nylm), listw = NYlistwW)
```


```{r}
spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = NY8,
 listw = NYlistwW)$lambda
```


<br>

#### 9.4.1.1 Modelos autorregresivos simultaneos


```{r}
nysar <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,
 data = NY8, listw = NYlistw)
summary(nysar)
```



```{r}
nylmw <- lm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = NY8,
 weights = POP8)
summary(nylmw)
```


```{r}
NY8$lmwresid <- residuals(nylmw)
```



```{r}
lm.morantest(nylmw, NYlistw)
```


```{r}
nysarw <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,
 data = NY8, listw = NYlistw, weights = POP8)
summary(nysarw)
```
<br>

#### 9.4.1.2 Modelos autorregresivos condicionales

```{r}
nycar <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,
 data = NY8, family = "CAR", listw = NYlistw)
summary(nycar)
```


```{r}
nycarw <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,
 data = NY8, family = "CAR", listw = NYlistw, weights = POP8)
summary(nycarw)
```

<br>


#### 9.4.1.3 Ajuste de modelos de regresión espacial


```{r}
nysarwM <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,
 data = NY8, family = "SAR", listw = NYlistw, weights = POP8,
 method = "Matrix")
summary(nysarwM)
```

```{r}
1/range(eigenw(NYlistw))
```

```{r}
nysar_ll <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,
 data = NY8, family = "SAR", listw = NYlistw, llprof = 100)
nysarw_ll <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,
 data = NY8, family = "SAR", listw = NYlistw, weights = POP8,
 llprof = 100)
```

```{r}
nysmaw <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,
 data = NY8, family = "SMA", listw = NYlistw, weights = POP8)
summary(nysmaw)
```

<br>

### 9.4.2 Enfoques de econometria espacial


El análisis espacial es muy apetecido porque se puede aplicar en diversas disciplinas científicas con diferentes enfoques. Un ejemplo es lo bienes raíces, este enfoque genera una gran cantidad de datos espaciales y estudiar su mercado resulta de mucha importancia para la economía, hay varios autores como Anselin que han presentado la econometría espacial, si bien ya mostramos como resolvimos un problema de salud publica puede ser más típico en un marco econométrico probrar primero la heteroscedasticidad e intentar aliviarla ajustando los errores estándar de los coeficientes:


```{r}
library(lmtest)
bptest(nylm)
```

Los resultados de la prueba de Breusch-Pagan indican la presencia de heteroscedasticidad cuando se regresan sobre las variables ya mencionadas anteriormente. Esto sugiere que se podría ajustar los errores estimados utilizando una matriz de varianza teniendo en cuenta la heteroscedasticidad:


```{r}
library(sandwich)
coeftest(nylm)
```


```{r}
coeftest(nylm, vcov = vcovHC(nylm, type = "HC4"))
```


```{r}
NYlistwW <- nb2listw(NY_nb, style = "W")
res <- lm.LMtests(nylm, listw = NYlistwW, test = "all")
tres <- t(sapply(res, function(x) c(x$statistic, x$parameter,
 x$p.value)))
colnames(tres) <- c("Statistic", "df", "p-value")
printCoefmat(tres)
```


```{r}
nylag <- lagsarlm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,
 data = NY8, listw = NYlistwW)
summary(nylag)
```

```{r}
bptest.sarlm(nylag)
```


```{r}
library(McSpatial)
McRes <- sarml(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,
 wmat = listw2mat(NYlistwW), eigvar = eigenw(NYlistwW),
 print = FALSE, data = NY8)
c(McRes$beta, rho = McRes$rho, sig2 = McRes$sig2)
```



```{r}
nymix <- lagsarlm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,
 data = NY8, listw = NYlistwW, type = "mixed")
nymix
```

```{r}
anova(nymix, nylag)
```


```{r}
W <- as(as_dgRMatrix_listw(NYlistwW), "CsparseMatrix")
trMat <- trW(W, type = "mult")
head(trMat)
```



```{r}
set.seed(987654)
imps <- impacts(nymix, tr = trMat, R = 1999)
imps
```

```{r}
HPDinterval(imps, choice = "direct")
```

```{r}
HPDinterval(imps, choice = "indirect")
```

```{r}
HPDinterval(imps, choice = "total")
```

```{r}
nyerr <- errorsarlm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,
 data = NY8, listw = NYlistwW)
summary(nyerr)
```

```{r}
LR.sarlm(nyerr, nymix)
```

```{r}
nyerr1 <- errorsarlm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,
 data = NY8, listw = NYlistwW, etype = "emixed")
coef(nyerr1)
```

```{r}
set.seed(987654)
resMCMC <- MCMCsamp(nyerr1, mcmc = 5000, burnin = 500,
 listw = NYlistwW)
```

```{r}
library(sphet)
nyGMlag <- spreg(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,
 data = NY8, listw = NYlistwW, model = "lag", het = FALSE)
summary(nyGMlag)
```



```{r}
nyGMerr <- spreg(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,
 data = NY8, listw = NYlistwW, model = "error", het = FALSE)
summary(nyGMerr)
```


```{r}
fit <- qregspiv(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,
 wmat = listw2mat(NYlistwW), data = NY8, tau = 0.5,
 nboot = 200)
```

<br>

### 9.4.3 Otros métodos


```{r}
library(mgcv)
NY8$x <- coordinates(NY8)[, 1]/1000
NY8$y <- coordinates(NY8)[, 2]/1000
nyGAM1 <- gam(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME +
 s(x, y), weights = POP8, data = NY8)
anova(nylmw, nyGAM1, test = "Chisq")
```


```{r}
nyGLMp <- glm(Cases ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME +
 offset(log(POP8)), data = NY8, family = "poisson")
summary(nyGLMp)
```



```{r}
nyGAMp <- gam(Cases ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME +
 offset(log(POP8)) + s(x, y), data = NY8, family = "poisson")
summary(nyGAMp)
```



```{r}
anova(nyGLMp, nyGAMp, test = "Chisq")
```

