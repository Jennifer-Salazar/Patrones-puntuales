---
title: "Contextualización base de datos de patrones puntuales"
author: "Jennifer Salazar"
date: ""
output:
  rmdformats::robobook
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE)
```


```{r}
# Medatados
library(readxl)
library(kableExtra)
library(spatstat)
library(rgeos)
library(sf)
library(rgdal)
```


## Contextualización de los datos

Conjunto de datos extraido de **Datos Abiertos - Metro de Medellín**: https://datosabiertos-metrodemedellin.opendata.arcgis.com/datasets/da53473c05de48e6af9e2ea6c95e7e06_0/about

Datos asociados a la subárea de la estadística espacial llamada patrones puntuales, que contiene información relacionada con la ubicación de los establecimientos que prestan el servicio de recarga de la tarjeta Cívica utilizada para acceder a los distintos modos de transporte del SITVA (Sistema Integrado de Transporte del Valle de Aburrá).

Se centra en los sitios por fuera de las estaciones, distribuidos en todo el Valle de Aburrá que componen la oferta que el Metro de Medellín pone a disposición de sus viajeros para que cada vez tengan más alternativas y comodidad a la hora de recargar la tarjeta Cívica.

La Metodología del levantamiento de los datos es mediante la digitalización a partir de imagen Satelital.

El sistema de referencia espacial es WGS 1984 Web Mercator (auxiliary sphere).


**¿Qué es la tarjeta cívica?**

En 2007 la Empresa de Transporte Masivo del Valle de Aburrá Limitada comenzó la implementación de Cívica para el recaudo e ingreso al Sistema METRO, por sus beneficios económicos, operativos y ambientales frente al tiquete de papel.


Esta Tarjeta Inteligente Sin Contacto (TISC), permite almacenar dinero para pagar tus desplazamientos en el METRO, los Cables, los Buses de las Líneas 1 y 2, las rutas Alimentadores de las cuencas 3, 6 y 7, y en el tranvía de Ayacucho.  Actualmente se trabaja para que poder utilizarla en las rutas integradas al Sistema.


## Variable de estudio

Localizaciones de los puntos de recarga de la tarjeta cívica del metro.


## Contextualización de las variables

* Metadatos

```{r}
Metadato <- read_excel("Metadato.xlsx")
kable(Metadato)  %>%
  kable_paper("hover", full_width = F)
```



## Pregunta de investigación

¿Cuales son los puntos/zonas/localizaciones más probables o menos probables para tener un establecimiento que realice recargas de la tarjeta cívica de manera que sean estratégicos como las localizaciones existentes para la empresa Metro?

### Visualización del conjunto de datos

```{r}
civica <- read.csv("Puntos_de_Recarga.csv", 
                     header = T, sep=",", 
                     dec = ".")


kable(head(civica)) %>%
  kable_paper("hover", full_width = F)
```




### Gráfica de los datos


```{r}
library(leaflet)
civica_loc <- leaflet(data=civica) %>% 
  
  addTiles() %>%  
  
  addCircleMarkers(lat=~latitud,lng=~longitud,color="green",radius=2)

civica_loc
```

<br>

### Conjunto de datos en formato Shape file

```{r}
## read in the data
shape_civica <- st_read("Puntos_de_Recarga_C%C3%ADvica.shp")
```



Se trabaja con los municipios del Valle de Aburra exceptuando las localizaciones de los municios de Barbosa, Girardota y Caldas ya que tienen pocas observaciones y quedan a los extremos de la zona de estudio

```{r}

shape_civica$municipio <- as.factor(shape_civica$municipio)

indices <- shape_civica$municipio %in% c("Barbosa", "Girardota", "Caldas")

shape_civica <- shape_civica[!indices, ]


civica.locations <- st_transform(shape_civica)
st_geometry(shape_civica)


class(civica.locations)
```


<br>

### Conversión de longitud-latitud a UTM (metros)

```{r, warning=FALSE, message=FALSE}

# Latitud - Longitud
data_long_lat <- as.matrix(data.frame(x=shape_civica$longitud,
                              y=shape_civica$latitud))
head(data_long_lat)

# Datos en metros (UTM)
data_UTM <- project(data_long_lat ,"+proj=utm +zone=18N +ellps=WGS84")
head(data_UTM)

```

<br>

### Creación del objeto ppp de las localizaciones de los puntos de recarga de la tarjeta cívica

* Se trabaja inicialmente con el borde del Valle de Áburra:

```{r}
# Lectura del shape de la región de interés:
coordinate.units <- c("metre", "metres")

library(maptools)
region <- st_read("Area-Metropolitana.shp")
region <- st_transform(region, crs = CRS("+proj=utm +zone=18N +ellps=WGS84"))

#plot(region)

win <- as(as(region, 'Spatial'), 'owin')
ppp.locations <- ppp(x = data_UTM[,1],
                     y = data_UTM[,2],
                     window = win)



unitname(ppp.locations) <- coordinate.units
ppp.locations <- as.ppp(ppp.locations)
plot(ppp.locations)
```



* Como hay zonas del Valle de Áburra sin observaciones (zonas rurales) se debe de considerar un nuevo borde o área de estudio para realizar los analisis con el fin de que no queden muchos espacios vacios (las localizaciones estan ubicadas principalmente en zonas urbanas)

```{r}
win <- ripras(ppp.locations)
ppp.locations <- ppp(x = data_UTM[,1],
                     y = data_UTM[,2],
                     window = win)
ppp.locations <- as.ppp(ppp.locations)
plot(ppp.locations)
```




### Intensidad

La intensidad es la densidad promedio de puntos o en otras palabras, el número esperado de puntos por unidad de área. La intensidad puede ser constante (uniforme) o puede variar de un lugar a otro (no uniforme o inhomogéneo).

Un enfoque para evaluar la intensidad es dividir el área de estudio en cuadrantes y contar el número de puntos que caen en cada cuadrante. Si los puntos tienen una intensidad uniforme y son completamente aleatorios, entonces los recuentos de cuadrantes deben ser números aleatorios de Poisson con media constante. Podemos probar esa hipótesis usando el estadístico de prueba de bondad de ajuste $χ^2$

```{r}
qc.loc <- quadratcount(ppp.locations, nx=3, ny=4)
plot(ppp.locations, pch=3, cex=0.6)
plot(qc.loc, add=T, textargs = list(col='red'))
```

<br>

### Test de homógeneidad o intensidad constante.


$$H_0: Aleatoriedad ~~ vs. ~~ Ha: $$

```{r}
quadrat.test(qc.loc)
```

El valor p es muy pequeño, lo que indica que la intensidad no es constante. 

<br>

## Estimación de la intensidad via Kernel

```{r}
intensidad <- density.ppp(ppp.locations, sigma = bw.scott(ppp.locations))

intensidadpoints <- density.ppp(ppp.locations, sigma = bw.scott(ppp.locations), at="points")


# Estimaciones de la intensidad
par(mfrow=c(1,2))
plot(intensidad, main = "Gráfico de probabilidad")
plot(intensidadpoints, main = "Gráfico de puntos")
```


```{r}
par(mfrow=c(2,3), mar=c(0,0,1,2))

# Ancho de banda por defecto
plot(density.ppp(ppp.locations), main = paste("Sigma (defecto):", round(attr(density.ppp(ppp.locations), "sigma"),3)))

# Ancho de banda: diggle
plot(density.ppp(ppp.locations, sigma = bw.diggle(ppp.locations)), main = paste("Sigma (diggle):", round(attr(density.ppp(ppp.locations, sigma = bw.diggle(ppp.locations)), "sigma"),3)))

# Ancho de banda: CvL
plot(density.ppp(ppp.locations, sigma = bw.CvL(ppp.locations)), main = paste("Sigma (CvL):", round(attr(density.ppp(ppp.locations, sigma = bw.CvL(ppp.locations)), "sigma"),3)))


# Ancho de banda: frac
plot(density.ppp(ppp.locations, sigma = bw.frac(ppp.locations)), main = paste("Sigma (frac):", round(attr(density.ppp(ppp.locations, sigma = bw.frac(ppp.locations)), "sigma"),3)))


# Ancho de banda: ppl
plot(density.ppp(ppp.locations, sigma = bw.ppl(ppp.locations)), main = paste("Sigma (ppl):", round(attr(density.ppp(ppp.locations, sigma = bw.ppl(ppp.locations)), "sigma"),3)))


# Ancho de banda: scott.iso
plot(density.ppp(ppp.locations, sigma = bw.scott.iso(ppp.locations)), main = paste("Sigma (scott.iso):", round(attr(density.ppp(ppp.locations, sigma = bw.scott.iso(ppp.locations)), "sigma"),3)))

```


### Ajuste de modelos

**Modelo base:**

Un modelo de Poisson homogéneo

Ejemplo: $λ_θ((x,y))=exp(θ_0)$ se ajusta:


```{r}
base.loc <- ppm(ppp.locations, ~1)
coef(base.loc)
```

<br>

**El modelo log-lineal:**

Un modelo de Poisson inhomogéneo con una intensidad logarítmica lineal en las coordenadas cartesianas. 

Ejemplo: $λ_θ((x,y))=exp(θ_0+θ_1x+θ_2y)$ se ajusta:


```{r}
loglin.loc <- ppm(ppp.locations, ~x+y)
coef(loglin.loc)
```

Este modelo específico se puede escribir en forma de:




<br>

**El modelo log-lineal en x:**

Un modelo de Poisson inhomogéneo con una intensidad logarítmica lineal en x. 

Ejemplo: $λ_θ((x,y))=exp(θ_0+θ_1x)$ se ajusta:


```{r}
loglin.loc.x <- ppm(ppp.locations, ~x)
coef(loglin.loc.x)
```

<br>

**El modelo log-lineal en y:**

Un modelo de Poisson inhomogéneo con una intensidad logarítmica lineal en y. 

Ejemplo: $λ_θ((x,y))=exp(θ_0+θ_1y)$ se ajusta:


```{r}
loglin.loc.y <- ppm(ppp.locations, ~y)
coef(loglin.loc.y)
```


<br>

**El log-cuadrático con término de interacción**

Un modelo de Poisson inhomogéneo con intensidad que es log-cuadrático y tiene un término de interacción en x e y. 

$λ_θ((x,y))=exp(θ_0+θ_1x+θ_2y+θ_3x^2+θ_4y^2+θ_5x⋅y)$ se ajusta mediante


```{r}
logquad.loc <- ppm(ppp.locations, ~polynom(x, y, 2))
coef(logquad.loc)
```

<br>

**El modelo log-cúbico  con término de interacción**

Un modelo de Poisson inhomogéneo con una intensidad que es log-cubico y tiene un término de interacción en x e y.


Ejemplo: $λ_θ((x,y))=exp(θ_0+θ1x+θ_2y+θ_3x^2+θ_4x*y+ +θ_5y^2+θ_6x^3+θ_7x^2y+θ_8xy^2+θ_9y^3)$ se ajusta mediante


```{r}
logcubic.loc <- ppm(ppp.locations, ~polynom(x, y, 3))
coef(logcubic.loc)
```


<br>

### Predicción del modelo


Estos modelos fueron creados para la predicción:

El valor devuelto por la función de ajuste de modelos ppm es un objeto de clase ppm que representa el modelo ajustado. Esto es análogo a otros objetos modelo en R y, por lo tanto, se pueden aplicar operaciones estándar, como trazar, predecir o coef, entre otras.

Combinamos el comando plot() con el comando predict() para visualizar las predicciones de los modelos ajustados para el conjunto de datos **ppp.locations**:


```{r}
par(mfrow=c(2,3),mar=c(0,0,1,2))

plot(predict(base.loc), main='Modelo base')
points(ppp.locations, pch=16, cex=0.2)

plot(predict(loglin.loc), main='log-linear')
points(ppp.locations, pch=16, cex=0.2)

plot(predict(loglin.loc.x), main='log-linear en x')
points(ppp.locations, pch=16, cex=0.2)

plot(predict(loglin.loc.y), main='log-linear en y')
points(ppp.locations, pch=16, cex=0.2)

plot(predict(logquad.loc), main='log-cuadrático con interacción')
points(ppp.locations, pch=16, cex=0.2)

plot(predict(logcubic.loc), main='log-cúbico con interacción')
points(ppp.locations, pch=16, cex=0.2)
```

Mediantes las predicciones de ajustes se resalta que:

* El modelo base por su estructura tiene una predicción constante.

* Se nota los cambios entre los modelos base, los log-lineales y log-polinomiales.

* Entre los modelos log lineales mediante los gráficos de predicción se resalta que el modelo con solo "y" y el modelo con "x e y" tienen predicciones similares en cambio el que esta respecto a "x" difiere un poco. 

* El modelo cuadrático y cúbico tienen predicciones muy similares lo que indica que no es necesario la inclusión del del termino cúbico, es decir, no es necesario ajustar un modelo de grado 3.


<br>


### Comprobación de los modelos de Poisson ajustados

Después de ajustar un modelo de proceso de punto a un conjunto de datos de patrones puntuales, debemos verificar que el modelo se ajuste bien y que cada suposición de componente del modelo sea apropiada.

Un enfoque informal, no probabilístico, consiste en examinar los residuos del modelo.

$$residual=observado−ajustado$$

Si el modelo se ajusta bien, entonces los residuos deben estar centrados alrededor de cero.


**Se aplica la función diagnostic.ppm() en los modelos ajustados:**


```{r, results="hide"}
par(mfrow=c(2,3),mar=c(1,1,2,2))
diagnose.ppm(base.loc, which = "smooth", main = "modelo base")
diagnose.ppm(loglin.loc, which = "smooth", main = 'log-linear')
diagnose.ppm(loglin.loc.x, which = "smooth", main = 'log-linear en x')
diagnose.ppm(loglin.loc.y, which = "smooth", main = 'log-linear en y')
diagnose.ppm(logquad.loc, which = "smooth", main = 'log-cuadrático')
diagnose.ppm(logcubic.loc, which = "smooth", main = 'log-cúbico')
```


* El resalta el comportamiento similar de los residuales en el modelo base y en todos los modelos log-lineales.

* Los residuales son similares en los modelos log-polinomiales.

* En general los residuales toman valores muy cercanos a cero (positivos y negativos)

* El ajuste tiende a ser mejor en el centro en el modelo base y en los log lineales en donde esta la mayor cantidad de localizaciones que entraron al estudio y en los modelos log-polinomiales tiende a ser mejor en el centro y en alguna de las esquinas de Berlin.


<hr>

```{r}
fryplot(ppp.locations, main='clustered', pch=16, cex=0.2)
```

## estimación de la función k asumiendo inhomogeneo(Kinhom) para el patrón de puntos de recarga de la civica:

para estimar la funcion k:
Kinhom: Inhomogeneo (intensidad no constante)

### Kinhom (asumiendo que la intensidad es no constante)


**Patrón original (Cluster)**

```{r}
plot(Kinhom(ppp.locations), main='clustered')
```

* $\hat{K}(r)>K(pois)(r)$: agrupamiento.

* Se evidencia el patrón agregado o de cluster, ya que sas curvas estimadas estan por encima de la teorica, por tanto es un patrón agregado - cluster.


<br>

## estimación de la función g asumiendo inhomogeneo(pcfinhom) para el patrón de puntos de recarga de la civica:

para estimar la funcion g:
pcfinhom: Inhomogeneo (intensidad no constante)

### pcfinhom (asumiendo que la intensidad es no constante)

```{r}
plot(pcfinhom(ppp.locations), main='clustered')
```

* Es evidente el patrón de cluster o agrupamiento, dado que toma valores muy altos en distancias pequeñas y en distancias grandes va convergiendo a la curva teorica.



## Envelopes

**Kest**

```{r}
Env_hom <- envelope(Y = ppp.locations, fun = Kest)
plot(Env_hom, main = "Envelopes homogeo")
```

**Kinhom**

```{r}
Env_inhom <- envelope(Y = ppp.locations, fun = Kinhom)
plot(Env_inhom, main = "Envelopes inhomogeneo")
```



**pcf**

```{r}
Env_hom_g <- envelope(Y = ppp.locations, fun = pcf)
plot(Env_hom_g, main = "Envelopes")
```

**pcfinhom**


```{r}
Env_inhom_g <- envelope(Y = ppp.locations, fun = pcfinhom)
plot(Env_inhom_g, main = "Envelopes")
```


<br>
### Referencias:

* Puntos de recaraga tarjeta Cívica. Fuente: Open
Data Metro Medellin. Url: https://datosabiertosmetrodemedellin.opendata.arcgis.com/


<hr>







