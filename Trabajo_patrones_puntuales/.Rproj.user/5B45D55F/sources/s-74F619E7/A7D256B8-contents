---
title: "Simulaci?n 2"
author: "melisa"
date: "26 de mayo de 2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


### Clase 26 de mayo


```{r}
library(spatstat)
```

```{r}
x <- rpoispp(100)
plot(x)
```


* Primera aplicación de función de adelgazamiento:

```{r}
p1 <- function(x,y) { ifelse(x < 0.5, 0.8, 0.2) }
y1 <- rthin(x, p1)


par(mfrow=c(1,2))
plot(x)
plot(y1)
```



* Segunda aplicación de función de adelgazamiento:

$$P(x,y)=e^{x-y-1}$$

```{r}
p2 <- function(x,y) {exp(x-y-1)}
y2 <- rthin(x, p2)

par(mfrow=c(1,2))
plot(x)
plot(y2)
```



## Berlin City Data

Revisar la p?gina: https://www.geo.fu-berlin.de/en/v/soga/Geodata-analysis/Spatial-Point-patterns/Berlin-city-data/index.html

Berlín es famosa por su vida nocturna en todo el mundo. El conjunto de datos con el que trabajaremos almacena la ubicación geográfica de clubes y bares ubicados en Berlín. Los datos se recopilan de OpenStreetMap (OSM). Los datos se descargaron de GEOFABRIK el 25 de junio de 2017 y contienen datos de OpenStreetMap al 22 de junio de 2017 (ver aquí).

Descargamos los datos y leemos el archivo osm_pois_p.shp, que corresponde al punto de interés en Berlín, usando la función st_read() del paquete sf.


* Se extrae los datos de la web

```{r}
# build a temporary folder on disk
temp <- tempfile()
download.url <- "https://userpage.fu-berlin.de/soga/300/30100_data_sets/spatial/"
zipfile <- "osm_pois_p.zip"

## download the file
download.file(paste0(download.url,zipfile),temp, mode="wb")
## unzip the file(s)
unzip(temp)
## close file connection
unlink(temp)
```

* carga de librerias y asignación del conjunto de datos

```{r}
library(rgeos)
library(sf)
## read in the data
berlin.features <- st_read("osm_pois_p.shp")
```



El breve informe impreso proporciona el nombre del archivo, el controlador (ESRI Shapefile), menciona que hay 49091 registros (indicados como características), representados como filas y 4 atributos (indicados como campos), representados como columnas.

Al observar los nombres de las columnas, nos damos cuenta de que la categoría relacionada con los datos del punto se almacena en la columna fclass.

* Nombre de las columnas del conjunto de datos

```{r}
colnames(berlin.features)
```


Al aplicar la función unique(), obtenemos una descripción general de las diferentes categorías representadas en el conjunto de datos.

* Valores (sin repetición) que toma la variable fclass (Son los lugares como bancos, restaurantes, bares, etc.)

```{r}
unique(berlin.features$fclass)
```


Ahora subdividimos nuestro conjunto de datos para incluir solo la categoría club nocturno y bar usando el | operador.

* Filtrando por los clubes nocturnos o bares:

```{r}
berlin.locations <- 
  berlin.features[berlin.features$fclass=='nightclub' |
                    berlin.features$fclass=='bar',
                  c('fclass', 'name')]

```


Limpiamos el conjunto de datos cambiando el nombre de la columna y quitando los niveles no utilizados de las variables de factores usando la función droplevels(). Luego trazamos la frecuencia relativa de las categorías en nuestro conjunto de datos combinando las funciones table(), prop.table() y barplot().


* Gráfico de frecuencias de los clubes nocturnos y bares

```{r}
# rename column from fclass to loc
colnames(berlin.locations)[1] <- 'loc'
# Conversión variable loc a factor
berlin.locations$loc <- as.factor(berlin.locations$loc)
# drop unused levels 
berlin.locations$loc <- droplevels(berlin.locations$loc)
# plot
barplot(prop.table(table(berlin.locations$loc)))
```


De acuerdo, como era de esperar, hay muchas más ubicaciones indicadas como bares en nuestro conjunto de datos en comparación con las ubicaciones indicadas como discotecas. Para obtener las cifras absolutas usamos la función table().

* Tabla de frecuencias para los dos niveles 

```{r}
table(berlin.locations$loc)
```


Para visualizar los datos los graficamos usando el paquete mapview.

* Gráfico de las localizaciones discriminado por bares y clubs

```{r}
library(mapview)
mapview(berlin.locations, 
        zcol='loc', 
        label=berlin.locations$name,
        legend=T)
```


Finalmente, proyectamos el conjunto de datos de berlin.locations al Sistema Europeo de Referencia Terrestre de 1989 (ETRS89/UTM zona 32N) para su uso posterior. Por lo tanto, usamos la función st_transform() y proporcionamos el identificador EPSG para la zona 32N de ERTS89/UTM, que es 25832.

```{r}
berlin.locations <- st_transform(berlin.locations, 25832)
st_geometry(berlin.locations)
```



### Regular spaced and random data

Con el fin de contrastar métodos estadísticos particulares para el análisis de patrones de puntos espaciales, construimos dos conjuntos de datos artificiales. Un conjunto de datos, berlin.random, consta de datos de puntos distribuidos aleatoriamente en el área de Berlín. El otro conjunto de datos, berlin.regular, consta de datos puntuales que se distribuyen de forma bastante regular en el área de Berlín.

Antes de comenzar con la generación de datos, debemos establecer la extensión geográfica. Por lo tanto, cargamos los límites del distrito (berlin.sf), un objeto sf, y lo trazamos.

* Borde de la región de estudio

```{r}
load(url("https://userpage.fu-berlin.de/soga/300/30100_data_sets/berlin_district.RData"))
plot(berlin.sf, main="")
```



Tomamos las especificaciones del cuadro delimitador de la variable berlin.sf para establecer la extensión geográfica para el proceso de generación de datos.

* Extrayendo los valores minimos y máximos

```{r}
xmin <- as.vector(st_bbox(berlin.sf)[1])
ymin <- as.vector(st_bbox(berlin.sf)[2])
xmax <- as.vector(st_bbox(berlin.sf)[3])
ymax <- as.vector(st_bbox(berlin.sf)[4])
```



### Random points


Primero generamos números uniformes aleatorios usando la función runif().

* Simulación de puntos aleatorios

```{r}
set.seed(1111) # set seed for reproducibility
## generate random uniform numbers
x.random <- runif(n = nrow(berlin.locations)*0.4, 
                  min = xmin, 
                  max = xmax)
y.random <- runif(n = nrow(berlin.locations)*0.4, 
                  min=ymin, 
                  max=ymax)
```


Luego combinamos los datos del vector de números aleatorios en un objeto data.frame y lo trazamos junto con el límite del distrito de Berlín.

* Gráfico de los puntos aleatorios y el contorno de Berlin

```{r}
## add to dataframe
berlin.random  <- data.frame('x' = x.random, 'y' = y.random)

plot(x=berlin.random$x, 
     y=berlin.random$y, 
     main="Random Points", 
     xlab="x", ylab="y", cex=.5, 
     asp=T)
plot(berlin.sf, add=T, border='blue', col=NA)
```



### Regular points

Primero generamos una secuencia de números usando la función seq().

* Simulación de puntos regulares

```{r}
x.regular <- seq(from=xmin, to=xmax,
                 length.out = sqrt(nrow(berlin.locations))*0.35)
y.regular <- seq(from=ymin,to=ymax,
                 length=sqrt(nrow(berlin.locations))*0.35)
```


Luego creamos un marco de datos a partir de todas las combinaciones de variables usando la función expand.grid().

* Gráfico de dispersión de los puntos regulares

```{r}
regular <- expand.grid(x.regular, y.regular)
plot(regular, asp=T)
```


Finalmente, agregamos algo de ruido a los puntos usando la función jitter(), combinamos los datos en un objeto data.frame, berlin.regular, y lo trazamos junto con el límite del distrito de Berlín.


* Gráfico de los puntos regulares y el contorno 

```{r}
x.regular <- jitter(regular[,1], factor = 1)
y.regular <- jitter(regular[,2], factor = 1)
berlin.regular <- data.frame('x' = x.regular, 'y' = y.regular)

plot(x=berlin.regular$x,
     y=berlin.regular$y, 
     main="Regular Points", 
     xlab="x",ylab="y", cex=.5, 
     asp=T)
plot(berlin.sf, add=T, border='blue', col=NA)
```



### Creating spatstat objects


En spatstat, un patrón de punto espacial en un espacio bidimensional se almacena como un objeto de clase ppp. Dicho objeto de patrón de puntos contiene las coordenadas espaciales de los puntos, las marcas adjuntas a ellos (si las hay), una ventana en la que se observaron los puntos y, opcionalmente, el nombre de la unidad de longitud para las coordenadas espaciales.

Un objeto ppp se crea usando la función ppp(). A la ventana de argumentos se le debe proporcionar un objeto de ventana de clase owin. La inclusión de información sobre las unidades de longitud en las que se registran las coordenadas x e y permite que el paquete spatstat imprima mejores informes y anote los ejes en los gráficos.


construimos tres objetos ppp, uno para el conjunto de datos berlin.locations, que denominaremos ppp.locations, uno para el conjunto de datos berlin.random, que denominamos ppp.random, y otro para el conjunto de datos berlin.regular, que denotamos como ppp.regular.

Los tres conjuntos de datos comparten la misma longitud en la que se registran las coordenadas x e y, metros, así como la ventana en la que se observaron los puntos, el cuadro delimitador de la frontera del distrito de Berlín (berlin.sf).

Unidades de coordenadas
Comenzamos con la asignación de una variable de marcador de posición que contiene la representación de cadena de las unidades de coordenadas.


```{r}
library(spatstat)
library(maptools)


coordinate.units <- c("metre", "metres")
```

Ventana
Un objeto de clase owin (ventana de observación) representa una región o ventana en un espacio bidimensional. La ventana puede ser un rectángulo, un polígono o polígonos, con agujeros poligonales o una forma irregular representada por una máscara de imagen de píxeles binarios.

Recuerde que berlin.sf es de clase sf.

```{r}
class(berlin.sf)
```


Para establecer la ventana en el polígono berlin.sf, primero debemos convertir berlin.sf en un objeto espacial, que luego se convierte en un objeto owin. Esto puede sonar complicado, pero al usar la función as() en secuencia, el objetivo se vuelve bastante simple.

```{r}
class(as(berlin.sf, 'Spatial'))
```


```{r}
class(as(as(berlin.sf, 'Spatial'), 'owin'))
```

Aquí vamos, ¡hecho! Ahora asignamos el objeto owin a una variable denotada como win.

```{r}
win <- as(as(berlin.sf, 'Spatial'), 'owin')
win
```


### ppp object

Finalmente, construimos objetos ppp a partir de nuestros tres conjuntos de datos diferentes, berlin.locations, berlin.regular y berlin.random usando la función ppp(). Recuerda que berlin.locations es un objeto sf, mientras que berlin.regular y berlin.random son objetos data.frame.

```{r}
class(berlin.locations)
class(berlin.regular)
class(berlin.random)
```


Para berlin.locations, el objeto sf, hacemos uso de la función st_coordinates() para extraer las coordenadas xy en forma de un objeto matriz. Repasemos las coordenadas de los primeros cinco puntos en berlín.ubicaciones en formato matricial.

```{r}
st_coordinates(berlin.locations)[1:5,]
```


Ahora, construyamos un objeto ppp, denominado ppp.locations.

```{r}
ppp.locations <- ppp(x = st_coordinates(berlin.locations)[,1],
                     y = st_coordinates(berlin.locations)[,2],
                     window = win)
```


Ahora asignamos el nombre de la unidad de longitud para las coordenadas espaciales al objeto ppp y lo trazamos.

```{r}
unitname(ppp.locations) <- coordinate.units
plot(ppp.locations)
```




Tenga en cuenta que recibimos una advertencia de que 1 punto fue rechazado por estar fuera de la ventana especificada. No se preocupe, los puntos rechazados en un patrón de puntos serán ignorados por todas las demás funciones excepto por plot. Todavía son accesibles y se almacenan como un atributo del patrón de puntos llamados rechazos.

No es muy fácil detectar el punto rechazado en el gráfico anterior, por lo tanto, escribamos un código para resaltar el punto rechazado. Hacemos uso de la función gIntersects() del paquete rgios.

```{r}
sp.locations <- as(berlin.locations, "Spatial")
sp.border <- as(berlin.sf, "Spatial")
i <- gIntersects(sp.locations, sp.border , byid=TRUE)

plot(sp.border)
points(sp.locations)
points(sp.locations@coords[!i,1],
       sp.locations@coords[!i,2], 
       col='red', cex=3, pch=3)
```



Ahora podemos detectar muy fácilmente el punto rechazado ya que está marcado con una cruz roja. Sin embargo, si queremos deshacernos de los puntos rechazados, debemos aplicar un pequeño truco: aplicar la función as.ppp() en el objeto ppp elimina los puntos rechazados.

```{r}
ppp.locations <- as.ppp(ppp.locations)
plot(ppp.locations)
```


No más advertencias, ¡genial!

Continuamos con la construcción de un objeto ppp para el conjunto de datos berlin.random y lo denotamos como ppp.random. Como berlin.random es un objeto data.frame, simplemente indexamos sus columnas con la notación $


```{r}
ppp.random <- ppp(x = berlin.random$x,
                  y = berlin.random$y,
                  window = win)


unitname(ppp.random) <- coordinate.units
```


Nuevamente nos deshacemos de los puntos rechazados.

```{r}
ppp.random <- as.ppp(ppp.random)
plot(ppp.random)
```

Finalmente, construimos un objeto ppp a partir del conjunto de datos berlin.regular y lo denotamos como ppp.regular.

```{r}
ppp.regular <- ppp(x = berlin.regular$x,
                   y = berlin.regular$y,
                   window = win)

unitname(ppp.regular) <- coordinate.units

ppp.regular  <- as.ppp(ppp.regular)
plot(ppp.regular)
```


Para un uso posterior, guardamos los tres conjuntos de datos.

```{r}
save(file = "ppp_data_berlin.RData", 
     ppp.locations, ppp.random, ppp.regular, berlin.locations)
```


```{r}
summary(ppp.locations)
```

```{r}
density(ppp.locations)
```

```{r}
plot(density(ppp.locations))
```



```{r}
plot(density(rpoispp(500)))
```

* Anchos de banda: distancia

```{r}
attr(density(rpoispp(500)), "sigma")
```



```{r}
attr(density(ppp.locations), "sigma")
```


# Mapas de probabilidad

```{r}
par(mfrow=c(3,3), mar=c(0,0,1,2))
sigma <- c(1000, 2500, 5000)
data <- list(ppp.locations, ppp.regular, ppp.random)
main <- c('Locations', 'Regular', 'Random')
for (i in 1:3){
  for (j in 1:3){
    ds <- density.ppp(data[[i]], sigma=sigma[j])
    plot(ds, 
         main = paste0(main[i], ', sigma: ', sigma[j]))
    plot(data[[i]], add=T, cex=0.01, regular=F)
    }
}
```


Ancho de banda diferente

```{r}
plot(density(ppp.locations, sigma = bw.diggle(ppp.locations)))
```



```{r}
par(mfrow=c(1,3))
plot(density(ppp.locations))
plot(density(ppp.locations, sigma = bw.diggle(ppp.locations)))
plot(density(ppp.locations, sigma = bw.CvL(ppp.locations)))


```


Tarea: explorar la densidad utilizando los diferentes anchos de banda (sigma = bw.) y decir que hace cada uno

```{r}
bw.abram()
bw.CvL()
bw.CvLHeat()
bw.diggle()
bw.frac()
bw.optim()
bw.pcf()
bw.ppl()
bw.pplHeat()
etc....
```

reportar el valor del ancho de banda

```{r}
bw.diggle(ppp.locations)
```


```{r}
?densityAdaptiveKernel
```


Ejemplo: bw.CvL(ppp.locations)


# Clase 31 de mayo



```{r}
library(spatstat)
?Kest
?Kinhom
```



```{r}
plot(ppp.locations)
```


Estimación de la intensidad:


```{r}
d <- density(ppp.locations)
plot(d)
```



```{r}
d <- density(ppp.locations, at="points")
d
```

* Valores en x de la ventana de observación 

```{r}
ppp.locations$window$bdry[[1]]$x
```


* Valores en y de la ventana de observación 

```{r}
ppp.locations$window$bdry[[1]]$y
```


* Número de puntos


```{r}
ppp.locations$n
```

* Coordenadas en x y en y

```{r}
ppp.locations$x
ppp.locations$y
```




```{r}
K <- Kest(ppp.locations)
K
```

Se recomienda usar trans e iso.

Funciones empiricas estimadas quedaron por encima para de la K teorica para un proceso completamente aleatorio (pois)
```{r}
plot(K)
```

Se esta asumiendo que la intensidad es constante.

El modelo que realmente nos va a interesar es el inhomogeneo


```{r}
Ki <- Kinhom(ppp.locations)
Ki
```


```{r}
plot(Ki)
```


* Función de correlación por pares


```{r}
?pcf
```


```{r}
g <- pcf(ppp.locations)
g
```


```{r}
plot(g)
```


* g inhomogeneo


```{r}
G <- pcfinhom(ppp.locations)
G
```


```{r}
plot(G)
```


La inhomogenea esta indicando que el patrón es mucho más agregado que en el caso homogeneo, ya que decae mucho más rápido.


* función para envolventes

```{r}
?envelope
```













