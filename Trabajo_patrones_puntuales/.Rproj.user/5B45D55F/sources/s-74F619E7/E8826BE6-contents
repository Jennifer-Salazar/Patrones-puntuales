---
title: "Análisis de datos geoestadísiticos de la presión atmosferica en departamentos de Colombia"
author: 
  - "Juan Esteban Sanchez"
  - "Miguel Angel Londoño"
  - "Jennifer Salazar"
date: ""
output:
  rmdformats::robobook
---

```{r setup, include=FALSE, warning=FALSE, message=FALSE, fig.align='center'}
knitr::opts_chunk$set(echo = TRUE)
```


## Contextualización de los datos

Datos geoestadísticos de la presión atmosférica medida en unidades de Hectopascales en el país de Colombia, las localizaciones de muestreo cubre principalmente el norte, occidente, noroccidente y suroccidente de Colombia, es decir los departamentos de: La Guajira, Magdalena, Cesar, Sucre, Córdoba, Bolivar, Norte de Santander, Antioquia, Santander, Boyacá, Chocó, Risaraldas, Caldas, Quindio, Cundinamarca, Bogotá, Valle del Cauca, Tolima, Cauca, Huila, Nariño y Putumayo.

Por otro lado tiene muy pocas zonas de muestreo en Caqueta, Guaviare, Casanare, Meta, Arauca y Vichada.

El sistema de referencia en el que se basa la base datos es el MAGNA-SIRGAS, que es el sistema oficial de Colombia, el cual hace uso del elipsoide GRS80.


**Nota:** Se toma una ventana de tiempo establecida (Enero-Abril del 2022), se calcula la presión atmosferica promedio para cada una de las localizaciones en esa ventana de tiempo con el fin de que la variable fecha o tiempo no determinen el comportamiento de la presión atmosférica, es decir, no se tenga que pensar en una tercera dimensión para el estudio.


## Variable de estudio

La **presión atmosférica** es la fuerza por unidad de superficie que ejerce el aire que forma la atmósfera sobre la superficie terrestre, conocer la presión atmosférica es esencial para predecir el tiempo y sus variaciones futuras. Es un buen complemento para la medición de la temperatura ambiente y la humedad.

## Fuente

Los datos fueron recopilados de la página de Datos abiertos del gobierno de Colombia. Los datos aquí dispuestos son datos crudos instantáneos provenientes de los sensores de las estaciones automáticas de la red propia y/o producto de convenios interadministrativos con terceras entidades.

* página de Datos abiertos del gobierno de Colombia:

https://www.datos.gov.co/

* página del conjunto de datos utilizado:

https://www.datos.gov.co/Ambiente-y-Desarrollo-Sostenible/Presi-n-Atmosf-rica/62tk-nxj5/data

La fecha de creación de los datos es el 27 de agosto de 2019, tiene fechas de medición desde marzo del 2001 hasta la actualidad, en diferentes horas del día. 

---

### Contextualización de las variables

* Metadatos

```{r}
# Medatados
library(readxl)
library(kableExtra)
Metadato <- read_excel("Metadato.xlsx")
kable(Metadato)  %>%
  kable_paper("hover", full_width = F)
```

<br>


### Pregunta de investigación

<center>

¿Es posible estimar la presión atmosférica promedio para el primer cuatrimestre del año 2022 para las diferentes zonas de Colombia donde no ha sido medida?

</center>


* Nota: el estudio se realiza para la presión atmosférica promedio usando la información tomada en el año 2022 (Enero-Abril) en cada una de las localizaciones, es decir, como en una localización la presión atmosférica puede ser medida en diferentes dias y en diferentes horas al dia, lo que realmente se esta considerando como presión atmosférica es el promedio de la presión en todos esos momentos registrados, teniendo un solo dato de la presión por localización.



### Visualización del conjunto de datos

```{r}
geo_data <- read.csv("Presion_atmosferica.csv", 
                     header = T, sep=",", 
                     dec = ".", encoding = "UTF-8")

kable(head(geo_data)) %>%
  kable_paper("hover", full_width = F)
```


<br>


* Se eliminan dos localizaciones retiradas de la zona de estudio: San Andrés y Leticia, con el fin de no generar ruido.



```{r}
geo_data$Municipio <- as.factor(geo_data$Municipio)

indices <- geo_data$Municipio %in% c("LETICIA", "SAN ANDRÉS")

geo_data <- geo_data[!indices, ]
```

---

* Se crea un conjunto de datos con la **presión atmosférica** promedio por localización 

```{r, warning=FALSE, message=FALSE}
library(dplyr)
geo_data2 <- geo_data %>% group_by(Latitud, Longitud) %>% summarise(Presion_media = mean(ValorObservado))
```



* Medidas descriptivas de las localizaciones (Latitud, Longitud) y de la presión atmosférica promedio.

```{r}
summary(geo_data2)
```


* La presión atmosferica promedio más pequeña presente en el conjunto de datos es de 500.2

* La presión atmosferica promedio más grande presente en el conjunto de datos es de 1013.4

--- 

### Gráfica de los datos

* Localizaciones de intéres para el estudio en el mapa de Colombia
* Radio de los circulos son el logaritmo de la presión atmosférica

```{r, warning=FALSE, message=FALSE}
library(leaflet)
presion_atmosferica <- leaflet(data=geo_data2) %>% 
  
  addTiles() %>%  
  
  addCircleMarkers(lat=~Latitud,lng=~Longitud,radius=~log(Presion_media), popup = ~as.character(round(Presion_media, 2)))

presion_atmosferica

```

---

### Conversión de los datos a metro (UTM)


* Primero se pasan de longitud, latitud a metros(UTM)

```{r, warning=FALSE, message=FALSE}
library(rgdal)

# Latitud - Longitud
data_long_lat <- as.matrix(data.frame(x=geo_data2$Longitud,
                              y=geo_data2$Latitud))
head(data_long_lat)

# Datos en metros (UTM)
data_UTM <- project(data_long_lat ,"+proj=utm +zone=18N +ellps=GRS80")
head(data_UTM)

# Datos en UTM más la presión
presionGeo <- cbind(data_UTM, Presion=geo_data2$Presion_media)
head(presionGeo)
```


<br>


### Análisis exploratorio de autocorrelación espacial

* Calculo de las distancias y disimilitudes

```{r, warning=FALSE, message=FALSE}
library(ggplot2)

# Matriz de distancias espaciales entre los lugaes de muestreo
geodist <- dist(presionGeo[,1:2], diag=TRUE, upper=TRUE)

# Matriz de distancias entre las observacioens registradas 
# en los lugares de muestreo de temperatura
dist.temp <- dist(presionGeo[,3], diag=TRUE, upper=TRUE)^2

# Creamos un data frame para extraer los valores de las matrices, ya sea la fracción triangular superior o inferior (en este ejemplo, utilizaremos la inferior, es decir: lower)
df <- data.frame(Disimilitud=dist.temp[lower.tri(dist.temp)], Distancia=geodist[lower.tri(geodist)])

```


<br>

* Gráfico de distancia vs disimilitud con linea de tendencia

```{r, warning=FALSE, message=FALSE, fig.align="center"}
plot <- ggplot(df, aes(x=Distancia, y=Disimilitud)) + 
  geom_point() + theme_test(base_size = 14, base_family = "Times New Roman") +
  labs(x="Distancia geográfica (m)", y="Disimilitud") +
  theme(axis.title = element_text(face="bold"), axis.text = element_text(colour="black")) +
  geom_smooth(method=lm)
plot
```

- La pendiente de la recta es positiva, por lo tanto da indicios de que existe autocorrelación parcial, es decir a medida que aumentan las distancias, aumenta la disimilutud.


<br>


* Covertir datos en formato geoR

```{r, warning=FALSE, message=FALSE, fig.align="center"}
# Covertir datos en formato geoR
library(geoR)
geodatos <- as.geodata(presionGeo,coords.col=1:2,data.col=3)
class(geodatos)
```

<br>

## Análisis descriptivo de datos geoestadísticos

* Gráficos descriptivos

```{r, warning=FALSE, message=FALSE, fig.align="center"}
# Gráficos descriptivos que indican que hay una correlación espacial
# El primer gráfico los colores estan divididos por cuartiles
plot(geodatos)
```



<br>

* Gráficos descriptivos en 3D

```{r,  fig.align="center"}
plot(geodatos, lowess = TRUE, scatter3d = TRUE) 
```

Mediante el primer gráfico de colores se percibe la presencia de autocorrelación espacial debido a que se visualiza las zonas de agrupación, se destaca que las cordilleras tienen presión atmosférica similar.


<br>

* Gráfico de dispersión con los puntos de localización y sus tonos respecto a la presión atmoferica.

```{r,  fig.align="center"}
points(geodatos, col = "gray", pt.divide = "equal")
```

* Es el gráfico de las localizaciones en un formato más sencillo


### Test de Mantel (Autocorrelación espacial)

Permite comprobar estadísticamente si las observaciones provienen de un proceso estocástico en el que las variables son correlacionadas espacialmente.


**Hipótesis**

$$H_0 : \text{Hay aleatoriedad espacial}$$
$$H_a : \text{Hay correlación espacial}$$

```{r, message=FALSE, warning=FALSE}
# Test de Mantel
library(vegan)
mantel(geodist, dist.temp) # vegan
```


```{r, warning=FALSE, message=FALSE}
library(ade4)
mantel.rtest(geodist, dist.temp, nrepet=999) # ade4
```

* Como el valor-p = 0.01 se rechaza la hipotesis nula y por tanto se concluye que hay autocorrelación espacial, es decir, las localizaciones más cercanas entre si, tienen valores similares en la presión atmosférica.

---


## Variogramas empíricos

Se ajustaran los variogramas nube y empírico 

```{r}
# Variograma cloud
cloud <- variog(geodatos,option="cloud")

# Semivariograma muestral
variograma <- variog(geodatos,option="bin",uvec=seq(0,800000,100000))
```


#### Representación gráfica del variograma

```{r, fig.align="center"}
par(mfrow=c(1,2), pty="s") # Preparar para 4 gráficos por ventana
plot(cloud, main="Nube de puntos variograma", col="cyan4")
grid()
plot(variograma, main="Variograma empírico", col="cyan4", pch=19)
grid()
```


La nube de variograma (Gráfico 1) da indicios de considerar realizar un variograma empírico con distancias de hasta 800000 metros.

Observando el variograma empírico se puede pensar en ajustar un modelo exponencial. 



### Ajuste de un modelo de variograma

Los estimadores empíricos no pueden ser empleados en la práctica (no verifican necesariamente las propiedades de un variograma válido), por lo que se suele recurrir en la práctica al ajuste de un modelo válido. Con el paquete geoR podemos realizar el ajuste:

* “A ojo”: representando diferentes modelos sobre un variograma empírico (usando la función lines.variomodel o la función eyefit).

* Por mínimos cuadrados: ajustando por mínimos cuadrados ordinarios (OSL) o ponderados (WLS) al variograma empírico (usando la función variofit).

* Por máxima verosimilitud: estimando por máxima verosimilitud (ML) o máxima verosimilitud restringida (REML) los parámetros a partir de los datos (utilizando la función likfit).



1) Mediante la función **eyefit** (A ojo)


$$\begin{array}{| c | c | c | c| c |}
\hline
Modelo~~Covarianza& Meseta & Rango\\
\hline
Exponencial & 19651.71 & 151351.35\\
\hline
\end{array}$$

```{r, eval=FALSE}
plot(variograma)
eyefit(variograma)
```


```{r, echo=FALSE,, fig.align="center"}
plot(variograma, pch=19, main="Variograma con Estimación con eyefit")
lines.variomodel(cov.model = "exp", cov.pars = c(19651.71,151351.35), nugget = 0, max.dist = 800000, lwd = 2, col="cyan4")
grid()
```

* Los ajustes mediante este modelo sirven para crear la malla de valores iniciales, con el objetivo de encontrar los valores de los parámetros óptimos.


<br>

2) Mediante la función **variofit** (mínimos cuadrados ordinarios: OLS)


* Se ajusta los modelos exponencial, gaussiano y esferico

Se crea una malla de valores iniciales para la meseta y el rango

```{r, fig.align="center"}
# Valores iniciales para los parametros de covarianza: meseta y rango
ini.vals <- expand.grid(seq(15000,25000,l=100), seq(0,300000,l=100))
```


* Ajuste de los modelos:

```{r, results="hide", warning=FALSE, message=FALSE}
vario_ols_exp=variofit(variograma, ini=ini.vals, cov.model="exponential",
                       wei="npair", min="optim")
vario_ols_gaus=variofit(variograma, ini=ini.vals, cov.model="gaussian",
                        wei="npair", min="optim", nugget = 0)
vario_ols_spe=variofit(variograma, ini=ini.vals,cov.model="spheric",
                       wei="npair", min="optim")
```


$$\begin{array}{| c | c | c | c| c |}
\hline
Modelo~~Covarianza& Pepita & Meseta & Rango\\
\hline
Exponencial & 3902.799 & 17901.127 & 247404.915\\
\hline
Gaussiano & 7337.469 & 13193.134 & 275115.928\\
\hline
Esferico & 5102.157 & 15195.927 & 538415.835\\
\hline
\end{array}$$

<br>

* Gráfico del varioagrama y sus ajustes mediante mínimos cuadrados ordinarios

```{r, fig.align="center"}
# Grafico del semivariograma
plot(variograma, xlab="Distancia (m)",ylab="Semivarianza", main = "Variograma con estimación mínimos cuadrados ordinarios", pch=19)
lines(vario_ols_exp,col="cyan4", lwd=2)
lines(vario_ols_gaus,col="blue", lwd=2)
lines(vario_ols_spe,col="purple", lwd=2)
grid()
legend("topleft", c("Expo", "Gaus","Spe"),col=c("cyan4","blue","purple") ,lwd=2)
```


<br>

3) Mediante la función **likfit** (máxima verosimilitud)

* Se ajusta los modelos mediante máxima verosimilitud y máxima verosimilitud restringida.

$$\begin{array}{| c | c | c | c| c |}
\hline
Modelo~~Covarianza& Pepita & Meseta & Rango\\
\hline
Exponencial~~ML & 2495.4 & 17611.5 & 180000.0\\
\hline
Exponencial~~REML & 2447.0 & 18066.0 & 180000.0\\
\hline
\end{array}$$

```{r, message=FALSE, warning=FALSE, fig.align="center", results="hide"}
# Semivariograma Máxima verosimilitud
vario_ml <- likfit(geodatos,ini.cov.pars=c(20000,180000),fix.nugget=FALSE,
              cov.model="exp", 
              fix.kappa=FALSE,lik.method="ML") # Maxima verosimilitud

# Semivariograma Máxima verosimilitud restringida
vario_reml <- likfit(geodatos,ini.cov.pars=c(20000,180000), fix.nugget=FALSE,
               cov.model="exp",
               fix.kappa=FALSE,lik.method="RML")
```




* Gráfico del varioagrama y sus ajustes mediante máxima verosimilitud

```{r, message=FALSE, warning=FALSE, fig.align="center"}
plot(variograma,xlab="Distancia", ylab="Semivarianza",   main="Variograma con estimación máxima verosimilitud", pch=19)
lines(vario_ml, lwd=2, lty = 1, col= "cyan4")
lines(vario_reml, lwd=2, lty=2, col="blue")
grid()
legend("topleft", c("ML", "REML"), lty=c(1,2), col=c("cyan4", "blue"), lwd=2)

```


### Inferencia sobre el variograma

Se verificará mediante el semivariograma la existencia de autocorrelación espacial,  mediante el método de no correlación espacial de Monte Carlo, que permite obtener bandas de confianza de no autocorrelación espacial:

* Bajo la hipótesis de que no hay correlación espacial (obtenidos por permutaciones aleatorias de los datos sobre las posiciones espaciales), para estudiar si hay una dependencia espacial “significativa”.


* Simulación del semivariograma con bandas de no correlación

(Test gráfico, bandas rojas(aleatoriedad) en donde si el variograma queda dentro de ellas no hay autocorrelación espacial)

```{r, message=FALSE, warning=FALSE, results="hide"}
par(mfrow=c(1,2))
plot(variograma, col="cyan4", pch=19)
grid()
for (i in 1:99) {
  geoP <- data.frame(geodatos$coords,sample(geodatos$data))
  geodatosP <- as.geodata(geoP,coords.col=1:2,data.col=3)
  variogramaP <- variog(geodatosP,option = "bin",uvec=seq(0,800000,100000))
  lines(variogramaP,type="l")
}

# Semivariograma con bandas de no correlación
plot(variograma,  pch=19, col="cyan4")
variograma_mc <- variog.mc.env(geodatos,obj=variograma,nsim=99)
lines(variograma_mc,col="red") 
grid()
```

* Se concluye que existe autocorrelación espacial debido a que el varioagrama no esta dentro de las bandas de no autocorrelación espacial.



## Predicción espacial (kriging)

El paquete geoR dispone de opciones para los métodos kriging tradicionales, que dependiendo de las suposiciones acerca de la función de tendencia se clasifican en:

Kriging simple (KS): media conocida

Kriging ordinario (KO): se supone que la media es constante y desconocida.

Kriging universal (KU): también denominado kriging con modelo de tendencia, se supone que la media es una combinación lineal (desconocida) de las coordenadas o de otras variables explicativas.


* Dado que la media es desconocida y se tiene indicios de que no sea constante, pero no se sabe con certeza, se decide probar tanto Kriging ordinario como universal.


Malla de zona de muestreo:

```{r}
# Rejilla regular 51x51 en cuadrado unidad
par(pty="s")
xx <- seq(0, 1200000, l = 51)
yy <- seq(0, 1400000, l = 51)
pred.grid <- expand.grid(x = xx, y = yy) 
plot(geodatos$coords, pch=19)
points(pred.grid, cex = 0.2)
```


<br>

## Kriging ordinario

### Ajustes con kriging (Modelos mediante mínimos cuadrados ordinarios)

* Modelo exponencial

```{r}
# Ajuste 
# Kriging: minimos cuadrados ordinarios 
kriging_ols_exp <- krige.conv(geodatos, loc = pred.grid, 
                          krige = krige.control(obj.m = vario_ols_exp))
```


* Modelo gaussiano

```{r}
# Ajuste 
# Kriging: minimos cuadrados ordinarios 
kriging_ols_gaus <- krige.conv(geodatos, loc = pred.grid, 
                          krige = krige.control(obj.m = vario_ols_gaus))
```

* Modelo esferico

```{r}
# Ajuste 
# Kriging: minimos cuadrados ordinarios 
kriging_ols_spe <- krige.conv(geodatos, loc = pred.grid, 
                          krige = krige.control(obj.m = vario_ols_spe))
```



### Ajustes con kriging (Modelos mediante máxima verosimilitud)


* Máxima verosimilitud

```{r}
# Ajuste 
# Kriging: máxima verosimilitud
kriging_ml <- krige.conv(geodatos, loc = pred.grid, 
                          krige = krige.control(obj.m = vario_ml))
```

* Máxima verosimilitud restringida


```{r}
# Ajuste 
# kriging: máxima verosimilitud restringida
kriging_reml <- krige.conv(geodatos, loc = pred.grid, 
                          krige = krige.control(obj.m = vario_reml))
```




### Gráficos de calor de las Predicciones y varianza:


* kriging con modelo exponencial:


```{r, fig.align="center"}
# Mapas de calor
par(pty="s")
# Prediccion
plot(pred.grid,main="Kriging ordinario",xlab="East",ylab="North")
image(kriging_ols_exp,add=TRUE)
contour(kriging_ols_exp,add=TRUE,drawlabels=TRUE)

# Varianza de la predicción
par(pty="s")
plot(pred.grid,main="Varianza",xlab="East",ylab="North")
image(kriging_ols_exp,values=sqrt(kriging_ols_exp$krige.var),add=TRUE)
contour(kriging_ols_exp,values=sqrt(kriging_ols_exp$krige.var),main="kriging estimates",add=TRUE,drawlabels=TRUE)
```

<br>


* kriging con modelo gaussiano:


```{r, fig.align="center"}
# Mapas de calor
par(pty="s")
# Prediccion
plot(pred.grid,main="Kriging ordinario",xlab="East",ylab="North")
image(kriging_ols_gaus,add=TRUE)
contour(kriging_ols_gaus,add=TRUE,drawlabels=TRUE)

# Varianza de la predicción
par(pty="s")
plot(pred.grid,main="Varianza",xlab="East",ylab="North")
image(kriging_ols_gaus,values=sqrt(kriging_ols_gaus$krige.var),add=TRUE)
contour(kriging_ols_gaus,values=sqrt(kriging_ols_gaus$krige.var),main="kriging estimates",add=TRUE,drawlabels=TRUE)
```

<br>


* kriging con modelo esferico:


```{r, fig.align="center"}
# Mapas de calor
par(pty="s")
# Prediccion
plot(pred.grid,main="Kriging ordinario",xlab="East",ylab="North")
image(kriging_ols_spe,add=TRUE)
contour(kriging_ols_spe,add=TRUE,drawlabels=TRUE)

# Varianza de la predicción
par(pty="s")
plot(pred.grid,main="Varianza",xlab="East",ylab="North")
image(kriging_ols_spe,values=sqrt(kriging_ols_spe$krige.var),add=TRUE)
contour(kriging_ols_spe,values=sqrt(kriging_ols_spe$krige.var),main="kriging estimates",add=TRUE,drawlabels=TRUE)
```


<br>

* kriging con modelo mediante máxima verosimilitud

```{r}
# Mapas de calor
par(pty="s")
# Prediccion
plot(pred.grid,main="Kriging ordinario",xlab="East",ylab="North")
image(kriging_ml,add=TRUE)
contour(kriging_ml,add=TRUE,drawlabels=TRUE)

# Varianza de la predicción
par(pty="s")
plot(pred.grid,main="Varianza",xlab="East",ylab="North")
image(kriging_ml,values=sqrt(kriging_ml$krige.var),add=TRUE)
contour(kriging_ml,values=sqrt(kriging_ml$krige.var),main="kriging estimates",add=TRUE,drawlabels=TRUE)
```



* kriging mediante modelo con máxima verosimilitud restringida

```{r}

# Mapas de calor
par(pty="s")
# Prediccion
plot(pred.grid,main="Kriging ordinario",xlab="East",ylab="North")
image(kriging_reml,add=TRUE)
contour(kriging_reml,add=TRUE,drawlabels=TRUE)

# Varianza de la predicción
par(pty="s")
plot(pred.grid,main="Varianza",xlab="East",ylab="North")
image(kriging_reml,values=sqrt(kriging_reml$krige.var),add=TRUE)
contour(kriging_reml,values=sqrt(kriging_reml$krige.var),main="kriging estimates",add=TRUE,drawlabels=TRUE)
```


### Kriging Universal


### Predicciones con kriging y varianzas de predicción gráficamente (mínimos cuadrados ordinarios)

* Mediante modelo exponencial

```{r}
# Ajuste Kriging
kriging_uni_ols_exp <- krige.conv(geodatos, loc = pred.grid,
                          krige = krige.control(nugget=0,
                                        trend.d="1st",
                                        trend.l="1st",
                                        obj.m = vario_ols_exp))

# Mapas de calor
par(pty="s")
# Prediccion
plot(pred.grid,main="Kriging universal",xlab="East",ylab="North")
image(kriging_uni_ols_exp,add=TRUE)
contour(kriging_uni_ols_exp,add=TRUE,drawlabels=TRUE)

# Varianza de la predicción
par(pty="s")
plot(pred.grid,main="Varianza",xlab="East",ylab="North")
image(kriging_uni_ols_exp,values=sqrt(kriging_uni_ols_exp$krige.var),add=TRUE)
contour(kriging_uni_ols_exp,values=sqrt(kriging_uni_ols_exp$krige.var),main="kriging estimates",add=TRUE,drawlabels=TRUE)
```


* Mediante modelo gaussiano

```{r}
# Ajuste Kriging
kriging_uni_ols_gaus <- krige.conv(geodatos, loc = pred.grid,
                          krige = krige.control(trend.d="1st",
                                        trend.l="1st",
                                        obj.m = vario_ols_gaus))

# Mapas de calor
par(pty="s")
# Prediccion
plot(pred.grid,main="Kriging universal",xlab="East",ylab="North")
image(kriging_uni_ols_gaus,add=TRUE)
contour(kriging_uni_ols_gaus,add=TRUE,drawlabels=TRUE)

# Varianza de la predicción
par(pty="s")
plot(pred.grid,main="Varianza",xlab="East",ylab="North")
image(kriging_uni_ols_gaus,values=sqrt(kriging_uni_ols_gaus$krige.var),add=TRUE)
contour(kriging_uni_ols_gaus,values=sqrt(kriging_uni_ols_gaus$krige.var),main="kriging estimates",add=TRUE,drawlabels=TRUE)
```



* Mediante modelo esferico

```{r}
# Ajuste Kriging
kriging_uni_ols_spe <- krige.conv(geodatos, loc = pred.grid,
                          krige = krige.control(nugget=0,
                                        trend.d="1st",
                                        trend.l="1st",
                                        obj.m = vario_ols_spe))

# Mapas de calor
par(pty="s")
# Prediccion
plot(pred.grid,main="Kriging universal",xlab="East",ylab="North")
image(kriging_uni_ols_spe,add=TRUE)
contour(kriging_uni_ols_spe,add=TRUE,drawlabels=TRUE)

# Varianza de la predicción
par(pty="s")
plot(pred.grid,main="Varianza",xlab="East",ylab="North")
image(kriging_uni_ols_spe,values=sqrt(kriging_uni_ols_spe$krige.var),add=TRUE)
contour(kriging_uni_ols_spe,values=sqrt(kriging_uni_ols_spe$krige.var),main="kriging estimates",add=TRUE,drawlabels=TRUE)
```




### Predicciones con kriging y varianzas de predicción gráficamente (máxima verosimilitud)


* Máxima verosimilitud


```{r}
# Ajuste Kriging
kriging_uni_ml <- krige.conv(geodatos, loc = pred.grid,
                          krige = krige.control(nugget=0,
                                        trend.d="1st",
                                        trend.l="1st",
                                        obj.m = vario_ml))

# Mapas de calor
par(pty="s")
# Prediccion
plot(pred.grid,main="Kriging universal",xlab="East",ylab="North")
image(kriging_uni_ml,add=TRUE)
contour(kriging_uni_ml,add=TRUE,drawlabels=TRUE)

# Varianza de la predicción
par(pty="s")
plot(pred.grid,main="Varianza",xlab="East",ylab="North")
image(kriging_uni_ml,values=sqrt(kriging_uni_ml$krige.var),add=TRUE)
contour(kriging_uni_ml,values=sqrt(kriging_uni_ml$krige.var),main="kriging estimates",add=TRUE,drawlabels=TRUE)
```


<br>

* Máxima verosimilitud restringida:

```{r}
# Ajuste Kriging
kriging_uni_reml <- krige.conv(geodatos, loc = pred.grid,
                          krige = krige.control(nugget=0,
                                        trend.d="1st",
                                        trend.l="1st",
                                        obj.m = vario_reml))

# Mapas de calor
par(pty="s")
# Prediccion
plot(pred.grid,main="Kriging universal",xlab="East",ylab="North")
image(kriging_uni_reml,add=TRUE)
contour(kriging_uni_reml,add=TRUE,drawlabels=TRUE)

# Varianza de la predicción
par(pty="s")
plot(pred.grid,main="Varianza",xlab="East",ylab="North")
image(kriging_uni_reml,values=sqrt(kriging_uni_reml$krige.var),add=TRUE)
contour(kriging_uni_reml,values=sqrt(kriging_uni_reml$krige.var),main="kriging estimates",add=TRUE,drawlabels=TRUE)
```


<br>

## Validación cruzada

* Mediante modelo exponencial

```{r, message=FALSE, fig.align="center", results="hide"}
vc_kriging_ols_exp <- xvalid(geodatos,model=vario_ols_exp)

par(mfrow=c(2,5))
plot(vc_kriging_ols_exp)
```


* Mediante modelo gaussiano

```{r, message=FALSE, fig.align="center", results="hide"}
vc_kriging_ols_gaus <- xvalid(geodatos,model=vario_ols_gaus)

par(mfrow=c(2,5))
plot(vc_kriging_ols_gaus)
```



* Mediante modelo esferico

```{r, message=FALSE, fig.align="center", results="hide"}
vc_kriging_ols_spe <- xvalid(geodatos,model=vario_ols_spe)

par(mfrow=c(2,5))
plot(vc_kriging_ols_spe)
```



* Mediante máxima verosimilitud

```{r}
vc_kriging_ml <- xvalid(geodatos,model=vario_ml)

par(mfrow=c(2,5))
plot(vc_kriging_ml)

```


* Mediante máxima verosimilitud restringida

```{r}
vc_kriging_reml <- xvalid(geodatos,model=vario_reml)

par(mfrow=c(2,5))
plot(vc_kriging_reml)
```




### Calculo del MSE para escoger el mejor modelo de ajuste:

```{r}
MSE_exp <- mean(vc_kriging_ols_exp$error^2)
MSE_gaus <- mean(vc_kriging_ols_gaus$error^2)
MSE_spe <- mean(vc_kriging_ols_spe$error^2)
MSE_ml <- mean(vc_kriging_ml$error^2)
MSE_reml <- mean(vc_kriging_reml$error^2)


# Error cuadratico medio modelo exponencial (mediante mínimos cuadrados ordinarios)
MSE_exp 

# Error cuadratico medio modelo gaussiano (mediante mínimos cuadrados ordinarios)
MSE_gaus 

# Error cuadratico medio modelo esferico (mediante mínimos cuadrados ordinarios)
MSE_spe 


# Error cuadratico medio modelo exponencial (mediante máxima verosimilitud)
MSE_ml 


# Error cuadratico medio modelo exponencial (mediante máxima verosimilitud restringida)
MSE_reml 
```

$$\begin{array}{| c | c | c | c| c |}
\hline
Modelo~~Covarianza & MSE\\
\hline
Exponencial & 5713.297 \\
\hline
Gaussiano & 7377.394 \\
\hline
Esferico & 6074.78 \\
\hline
Exponencial~~ML & 5556.416 \\
\hline
Exponencial~~RML & 5550.253\\
\hline
\end{array}$$

* El mejor modelo es el ajustado mediante máxima verosimilitud restringida.

### Predicción y varianza del mejor modelo:

* Kriging Ordinario:

```{r}
# Mapas de calor
par(pty="s")
# Prediccion
plot(pred.grid,main="Kriging ordinario",xlab="East",ylab="North")
image(kriging_reml,add=TRUE)
contour(kriging_reml,add=TRUE,drawlabels=TRUE)

# Varianza de la predicción
par(pty="s")
plot(pred.grid,main="Varianza",xlab="East",ylab="North")
image(kriging_reml,values=sqrt(kriging_reml$krige.var),add=TRUE)
contour(kriging_reml,values=sqrt(kriging_reml$krige.var),main="kriging estimates",add=TRUE,drawlabels=TRUE)
```


* Kriging universal:

```{r}
# Mapas de calor
par(pty="s")
# Prediccion
plot(pred.grid,main="Kriging universal",xlab="East",ylab="North")
image(kriging_uni_reml,add=TRUE)
contour(kriging_uni_reml,add=TRUE,drawlabels=TRUE)

# Varianza de la predicción
par(pty="s")
plot(pred.grid,main="Varianza",xlab="East",ylab="North")
image(kriging_uni_reml,values=sqrt(kriging_uni_reml$krige.var),add=TRUE)
contour(kriging_uni_reml,values=sqrt(kriging_uni_reml$krige.var),main="kriging estimates",add=TRUE,drawlabels=TRUE)
```


Ambos tipos de Kriging nos llevan a las siguientes conclusiones:

**Interpretaciones:** 

* Las zonas donde están las cordilleras tienden a tener valores en la presión atmosférica promedio mas bajos, por lo que se espera es que esa zona hubiera sido más afectada por las lluvias en el primer cuatrimestre del año,  y por otro lado, las zonas alrededor, especialmente las zonas costeras que están al borde de Colombia tienen presión atmosférica más alta, exceptuando la Sierra Nevada de Santa Marta.

* A medida que estamos más al centro de nuestra zona de muestreo hay menor varianza y a medida que nos alejamos se presenta una mayor varianza, es decir, hay una mayor variabilidad en las zonas más cercanas al borde de Colombia y menor variabilidad en las cordilleras y departamentos cercanos a estas, cabe resaltar que hay menor varianza en las zonas donde había más unidades de muestreo.

![](La-presion-atmosferica.jpg)


# Gráfico de predicciones en 3D con el mejor modelo

El eje z indica la presión atmosférica predicha, de tal manera que permite tener una mejor idea de la presión atmosférica promedio de las zonas abarcadas en este estudio.


```{r, eval=FALSE, echo=FALSE}
require(plot3D)
persp3D(xx, yy, matrix(kriging_uni_reml$predict, nrow = length(xx)), theta=-40, phi=40)
```


```{r}
fcol <- topo.colors(10)[cut(matrix(kriging_uni_reml$pred,nrow=50,ncol=50)[-1,-1],10,include.lowest=TRUE)]
persp(kriging_uni_reml, theta=-40, phi=40, col=fcol)
```



```{r, echo=FALSE, eval=FALSE}
library(spatstat.core)
x_obs <- c(min(geo_data2$Longitud), max(geo_data2$Longitud))
y_obs <- c(min(geo_data2$Latitud), max(geo_data2$Latitud))
obs_window <- owin(x_obs, y_obs)

ppp_temp <- ppp(geo_data2$Longitud, geo_data2$Latitud,
                 marks = geo_data2$Presion_media, window = obs_window)

idw_temp <- idw(ppp_temp, power = 2, at = "pixels")

plot(idw_temp,
     col = heat.colors(20), 
     main = "Interpolación IDW \n para la presión atmosférica promedio") 

```

